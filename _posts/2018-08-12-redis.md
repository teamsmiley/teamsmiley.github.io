---
layout: post
title: 'Redis 기본' 
author: teamsmiley
date: 2018-08-12
tags: [docker,redis]
image: /files/covers/blog.jpg
category: {macosx}
---
# redis를 설치하고 사용한다. 

## 설치 

```bash
vi docker-compose.yml
```
```yml
---
version: "3.3"

services:
  redis:
    image: redis:4.0.11
    ports:
      - "6379:6379"
    command: ["redis-server", "--appendonly", "yes"]
```
```bash
docker stack deploy -c docker-compose.yml redis
```

##  클라이언트에서 서버에 접속해보자.

윈도우즈 클라이언트 다운로드 
https://github.com/dmajkic/redis/downloads

redis-cli -h docker01.rendercore.com

접속 확인 완료 

## c#에서 사용

### 사용전 알아야할것 

기존에는 컨트롤러에서 디비를 가져와서 json으로 만들어서 프론트앤드에 보내준다.

이제 레디스에 데이터가 있는지 먼저 체크하여 있으면 json 만들어서 보내고 없으면 디비에서 가져와서 레디스에 넣고 그 결과값을 클라이언트에게 보낸다.

캐싱을 하려면 키값이 잇어야하는데 쿼리스트링까지 다 넣어서 키를 만들어야한다.

### 누겟 설치 

dotnet add package StackExchange.Redis.Extensions.Newtonsoft

### 코드 수정

appsetting.json에 다음 추가
```json
 "Redis": {
    //"Password": "my_super_secret_password",
    //"AllowAdmin": true,
    "Ssl": false,
    // "ConnectTimeout": 6000,
    // "ConnectRetry": 2,
    "Database": 0,
    "Hosts": [
      {
        "Host": "docker01.rendercore.com",
        "Port": "6379"
      }
    ]
  }
  ```

startup 에 다음 추가

```cs
    public void ConfigureServices(IServiceCollection services)
    {
      var redisConfiguration = Configuration.GetSection("Redis").Get<RedisConfiguration>();

      services.AddSingleton(redisConfiguration);
      services.AddSingleton<ICacheClient, StackExchangeRedisCacheClient>();
      services.AddSingleton<ISerializer, NewtonsoftSerializer>();
```

BaseResourceParameters에 tostring을 추가를 해서 쿼리스트링을 받는 객체를 스트링으로 바꾸어주자.

```cs
public override string ToString()
    {
      StringBuilder sb = new StringBuilder();

      foreach (var property in this.GetType().GetProperties())
      {
        sb.Append(property.Name + "=" + property.GetValue(this, null) + "/");
      }

      return sb.ToString();
    }
```

이제 컨트롤러에서 작업이 들어오면 캐싱이 잇는지 체크하고 잇으면 리턴하자.  없으면 데이터 리턴 직전에 캐싱에 넣자.

BoardDocumentsController

```cs
private readonly ICacheClient _cache;
public BoardDocumentsController(..., ICacheClient cache){
    _cache = cache;
}

...

private IActionResult GetSpecificDocuments<T>(string boardName, BoardDocumentsResourceParameters param) where T : class
{
  var key = boardName + ":" + param;
  var cache = _cache.Get<IEnumerable<T>>(key);
  if (cache != null)
  {
    return Ok(cache);
  }

  //기존로직 데이터를 디비에서 가져와서 넣는다.

    var result = Mapper.Map<IEnumerable<T>>(Document).ShapeData(param.Fields);

    bool added = _cache.Add(key, result, DateTimeOffset.Now.AddMinutes(10));

    return Ok(result);

```
리턴할 객체를 매핑이 다 끝나면 레디스에 저장을 한번 한다. 10분동안 가지고 있음

키값을 확인해보면 다음과 같다. 

## redis database 변경 

select 1 : database바꾸기 

## redis password setting

설정파일에서 세팅한다. 
sudo vi /etc/redis/redis.conf

requirepass xxxx

sudo /etc/init.d/redis-server restart

redis-cli -h 204.16.116.12  여전히 접속을 해보면 접속은 된다. 그런데 명령어를 치면 에러가 난다.

auth xxx

이렇게 비번을 넣으면 그 후에는 잘 동작한다. 

## pagination 이 json이 대문자로 나옴
헤더에 넣기때문에 객체를 던질수 없어서 startup.cs 에 설정부분이 동작하지 않는다.  그래서 이렇게 강제로 코딩해줘야함. 
```cs
var settings = new JsonSerializerSettings() { ContractResolver = new CamelCasePropertyNamesContractResolver() };

Response.Headers.Add("X-Pagination", JsonConvert.SerializeObject(cacheHeader, settings));
```

## key 값이 apiurl을 포함하면 좋겟음.
var key = Request.Path + ":" + boardName + ":" + param;
이렇게 햇음 
url : parameter : pagination? 이렇게 해야될듯 

## 글을 보는 페이지도 캐싱하자.

## 글을 지우면 캐싱에서 삭제되야함

글 내용 캐싱도 지워져야 하고 리스트에서도 새로 캐싱되어야한다.
게시물 제목이 속한 것이 지워져야한다. 

new 하면 리스트가 지워져야한다. 




## 해야할일 

글 업데이트시 글 캐시 삭제 글 리스트 삭제

캐싱 하는 코드가 반복되는데 정리가 안되나?


### redis delete all keys

FLUSHDB





